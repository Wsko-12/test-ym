<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        if(false){
            (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
                m[i].l=1*new Date();
                for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
                k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
            (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

            ym(102462605, "init", {
                clickmap:true,
                trackLinks:true,
                accurateTrackBounce:true,
                webvisor:true
            });
        }
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/102462605" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->





    <script>
        if(false){
            const start = performance.now();
            // Initialize the agent on page load.
            const fpPromise = import('https://fpjscdn.net/v3/cheURAKfVuViSYMWYbi2')
                .then(FingerprintJS => FingerprintJS.load());

            // Pass your own data to get()
            fpPromise
                .then(fp => fp.get())
                .then(result => {
                    console.log(result);
                    console.log(performance.now() - start)
                });

        }


    </script>

    <!-- <script src="https://wsko-12.github.io/wwskgithubo.js"></script> -->
</head>
<body>
<h1 id="fingerprint"></h1>
</body>
<script>
    const p =           document.createElement("p")
    document.body.appendChild(p )

    navigator.storage.getDirectory().then(({kind}) => {
        p.innerText = kind
    }).catch((e) => {
        p.innerText = e.message
    })
</script>

<script type="module">
    const hasFont = (function () {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const testText = "mmmmmmmmmmlli";

        const baseFonts = ["monospace", "serif", "sans-serif"];

        const baseSizes = baseFonts.map(base => {
            ctx.font = `20px ${base}`;
            return ctx.measureText(testText).width;
        });

        return function (font) {
            return baseSizes.some((baseWidth, i) => {
                ctx.font = `20px "${font}", ${baseFonts[i]}`;
                const width = ctx.measureText(testText).width;
                return width !== baseWidth;
            });
        };
    })();

    const HARDWARE = {};
    const HARDWARE_UNSTABLE = {}
    const PERIPHERAL_HARDWARE = {};
    const OS_PARTIALLY_STABLE = {};
    const OS_RARELY_CHANGEABLE = {};
    const UNSTABLE = {};

    const HEAP = {
        gamepad: (navigator.getGamepads && navigator.getGamepads().length.toString()) || "NA",
        wgslFeatures: (() => {
            if(navigator.gpu && navigator.gpu.wgslLanguageFeatures && navigator.gpu.wgslLanguageFeatures.keys){
                return Array.from(navigator.gpu.wgslLanguageFeatures.keys()).join("")
            }else {
                return "NA"
            }
        })()
    };

    const renderResult = () => {
        const code = document.createElement("code");

        [
            ["HARDWARE", HARDWARE],
            ["HARDWARE_UNSTABLE", HARDWARE_UNSTABLE],
            ["OS_PARTIALLY_STABLE", OS_PARTIALLY_STABLE],
            ["OS_RARELY_CHANGEABLE", OS_RARELY_CHANGEABLE],
            ["UNSTABLE", UNSTABLE],
            ["HEAP", HEAP],
        ].forEach(([name, obj]) => {
            const pre = document.createElement("pre");
            code.appendChild(pre);
            pre.innerText += `${name}:\n ${JSON.stringify(obj, null, 2)} \n\n`;
        });

        document.body.appendChild(code);
    };

    const x = [
        "ACTIVE_ATTRIBUTES",
        "ACTIVE_TEXTURE",
        "ACTIVE_UNIFORMS",
        "ALIASED_LINE_WIDTH_RANGE",
        "ALIASED_POINT_SIZE_RANGE",
        "ALPHA",
        "ALPHA_BITS",
        "ALWAYS",
        "ARRAY_BUFFER",
        "ARRAY_BUFFER_BINDING",
        "ATTACHED_SHADERS",
        "BACK",
        "BLEND",
        "BLEND_COLOR",
        "BLEND_DST_ALPHA",
        "BLEND_DST_RGB",
        "BLEND_EQUATION",
        "BLEND_EQUATION_ALPHA",
        "BLEND_EQUATION_RGB",
        "BLEND_SRC_ALPHA",
        "BLEND_SRC_RGB",
        "BLUE_BITS",
        "BOOL",
        "BOOL_VEC2",
        "BOOL_VEC3",
        "BOOL_VEC4",
        "BROWSER_DEFAULT_WEBGL",
        "BUFFER_SIZE",
        "BUFFER_USAGE",
        "BYTE",
        "CCW",
        "CLAMP_TO_EDGE",
        "COLOR_ATTACHMENT0",
        "COLOR_BUFFER_BIT",
        "COLOR_CLEAR_VALUE",
        "COLOR_WRITEMASK",
        "COMPILE_STATUS",
        "COMPRESSED_TEXTURE_FORMATS",
        "CONSTANT_ALPHA",
        "CONSTANT_COLOR",
        "CONTEXT_LOST_WEBGL",
        "CULL_FACE",
        "CULL_FACE_MODE",
        "CURRENT_PROGRAM",
        "CURRENT_VERTEX_ATTRIB",
        "CW",
        "DECR",
        "DECR_WRAP",
        "DELETE_STATUS",
        "DEPTH_ATTACHMENT",
        "DEPTH_BITS",
        "DEPTH_BUFFER_BIT",
        "DEPTH_CLEAR_VALUE",
        "DEPTH_COMPONENT",
        "DEPTH_COMPONENT16",
        "DEPTH_FUNC",
        "DEPTH_RANGE",
        "DEPTH_STENCIL",
        "DEPTH_STENCIL_ATTACHMENT",
        "DEPTH_TEST",
        "DEPTH_WRITEMASK",
        "DITHER",
        "DONT_CARE",
        "DST_ALPHA",
        "DST_COLOR",
        "DYNAMIC_DRAW",
        "ELEMENT_ARRAY_BUFFER",
        "ELEMENT_ARRAY_BUFFER_BINDING",
        "EQUAL",
        "FASTEST",
        "FLOAT",
        "FLOAT_MAT2",
        "FLOAT_MAT3",
        "FLOAT_MAT4",
        "FLOAT_VEC2",
        "FLOAT_VEC3",
        "FLOAT_VEC4",
        "FRAGMENT_SHADER",
        "FRAMEBUFFER",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
        "FRAMEBUFFER_BINDING",
        "FRAMEBUFFER_COMPLETE",
        "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
        "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
        "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
        "FRAMEBUFFER_UNSUPPORTED",
        "FRONT",
        "FRONT_AND_BACK",
        "FRONT_FACE",
        "FUNC_ADD",
        "FUNC_REVERSE_SUBTRACT",
        "FUNC_SUBTRACT",
        "GENERATE_MIPMAP_HINT",
        "GEQUAL",
        "GREATER",
        "GREEN_BITS",
        "HIGH_FLOAT",
        "HIGH_INT",
        "IMPLEMENTATION_COLOR_READ_FORMAT",
        "IMPLEMENTATION_COLOR_READ_TYPE",
        "INCR",
        "INCR_WRAP",
        "INT",
        "INT_VEC2",
        "INT_VEC3",
        "INT_VEC4",
        "INVALID_ENUM",
        "INVALID_FRAMEBUFFER_OPERATION",
        "INVALID_OPERATION",
        "INVALID_VALUE",
        "INVERT",
        "KEEP",
        "LEQUAL",
        "LESS",
        "LINEAR",
        "LINEAR_MIPMAP_LINEAR",
        "LINEAR_MIPMAP_NEAREST",
        "LINES",
        "LINE_LOOP",
        "LINE_STRIP",
        "LINE_WIDTH",
        "LINK_STATUS",
        "LOW_FLOAT",
        "LOW_INT",
        "LUMINANCE",
        "LUMINANCE_ALPHA",
        "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
        "MAX_CUBE_MAP_TEXTURE_SIZE",
        "MAX_FRAGMENT_UNIFORM_VECTORS",
        "MAX_RENDERBUFFER_SIZE",
        "MAX_TEXTURE_IMAGE_UNITS",
        "MAX_TEXTURE_SIZE",
        "MAX_VARYING_VECTORS",
        "MAX_VERTEX_ATTRIBS",
        "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
        "MAX_VERTEX_UNIFORM_VECTORS",
        "MAX_VIEWPORT_DIMS",
        "MEDIUM_FLOAT",
        "MEDIUM_INT",
        "MIRRORED_REPEAT",
        "NEAREST",
        "NEAREST_MIPMAP_LINEAR",
        "NEAREST_MIPMAP_NEAREST",
        "NEVER",
        "NICEST",
        "NONE",
        "NOTEQUAL",
        "NO_ERROR",
        "ONE",
        "ONE_MINUS_CONSTANT_ALPHA",
        "ONE_MINUS_CONSTANT_COLOR",
        "ONE_MINUS_DST_ALPHA",
        "ONE_MINUS_DST_COLOR",
        "ONE_MINUS_SRC_ALPHA",
        "ONE_MINUS_SRC_COLOR",
        "OUT_OF_MEMORY",
        "PACK_ALIGNMENT",
        "POINTS",
        "POLYGON_OFFSET_FACTOR",
        "POLYGON_OFFSET_FILL",
        "POLYGON_OFFSET_UNITS",
        "RED_BITS",
        "RENDERBUFFER",
        "RENDERBUFFER_ALPHA_SIZE",
        "RENDERBUFFER_BINDING",
        "RENDERBUFFER_BLUE_SIZE",
        "RENDERBUFFER_DEPTH_SIZE",
        "RENDERBUFFER_GREEN_SIZE",
        "RENDERBUFFER_HEIGHT",
        "RENDERBUFFER_INTERNAL_FORMAT",
        "RENDERBUFFER_RED_SIZE",
        "RENDERBUFFER_STENCIL_SIZE",
        "RENDERBUFFER_WIDTH",
        "RENDERER",
        "REPEAT",
        "REPLACE",
        "RGB",
        "RGB5_A1",
        "RGB8",
        "RGB565",
        "RGBA",
        "RGBA4",
        "RGBA8",
        "SAMPLER_2D",
        "SAMPLER_CUBE",
        "SAMPLES",
        "SAMPLE_ALPHA_TO_COVERAGE",
        "SAMPLE_BUFFERS",
        "SAMPLE_COVERAGE",
        "SAMPLE_COVERAGE_INVERT",
        "SAMPLE_COVERAGE_VALUE",
        "SCISSOR_BOX",
        "SCISSOR_TEST",
        "SHADER_TYPE",
        "SHADING_LANGUAGE_VERSION",
        "SHORT",
        "SRC_ALPHA",
        "SRC_ALPHA_SATURATE",
        "SRC_COLOR",
        "STATIC_DRAW",
        "STENCIL_ATTACHMENT",
        "STENCIL_BACK_FAIL",
        "STENCIL_BACK_FUNC",
        "STENCIL_BACK_PASS_DEPTH_FAIL",
        "STENCIL_BACK_PASS_DEPTH_PASS",
        "STENCIL_BACK_REF",
        "STENCIL_BACK_VALUE_MASK",
        "STENCIL_BACK_WRITEMASK",
        "STENCIL_BITS",
        "STENCIL_BUFFER_BIT",
        "STENCIL_CLEAR_VALUE",
        "STENCIL_FAIL",
        "STENCIL_FUNC",
        "STENCIL_INDEX8",
        "STENCIL_PASS_DEPTH_FAIL",
        "STENCIL_PASS_DEPTH_PASS",
        "STENCIL_REF",
        "STENCIL_TEST",
        "STENCIL_VALUE_MASK",
        "STENCIL_WRITEMASK",
        "STREAM_DRAW",
        "SUBPIXEL_BITS",
        "TEXTURE",
        "TEXTURE0",
        "TEXTURE1",
        "TEXTURE2",
        "TEXTURE3",
        "TEXTURE4",
        "TEXTURE5",
        "TEXTURE6",
        "TEXTURE7",
        "TEXTURE8",
        "TEXTURE9",
        "TEXTURE10",
        "TEXTURE11",
        "TEXTURE12",
        "TEXTURE13",
        "TEXTURE14",
        "TEXTURE15",
        "TEXTURE16",
        "TEXTURE17",
        "TEXTURE18",
        "TEXTURE19",
        "TEXTURE20",
        "TEXTURE21",
        "TEXTURE22",
        "TEXTURE23",
        "TEXTURE24",
        "TEXTURE25",
        "TEXTURE26",
        "TEXTURE27",
        "TEXTURE28",
        "TEXTURE29",
        "TEXTURE30",
        "TEXTURE31",
        "TEXTURE_2D",
        "TEXTURE_BINDING_2D",
        "TEXTURE_BINDING_CUBE_MAP",
        "TEXTURE_CUBE_MAP",
        "TEXTURE_CUBE_MAP_NEGATIVE_X",
        "TEXTURE_CUBE_MAP_NEGATIVE_Y",
        "TEXTURE_CUBE_MAP_NEGATIVE_Z",
        "TEXTURE_CUBE_MAP_POSITIVE_X",
        "TEXTURE_CUBE_MAP_POSITIVE_Y",
        "TEXTURE_CUBE_MAP_POSITIVE_Z",
        "TEXTURE_MAG_FILTER",
        "TEXTURE_MIN_FILTER",
        "TEXTURE_WRAP_S",
        "TEXTURE_WRAP_T",
        "TRIANGLES",
        "TRIANGLE_FAN",
        "TRIANGLE_STRIP",
        "UNPACK_ALIGNMENT",
        "UNPACK_COLORSPACE_CONVERSION_WEBGL",
        "UNPACK_FLIP_Y_WEBGL",
        "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
        "UNSIGNED_BYTE",
        "UNSIGNED_INT",
        "UNSIGNED_SHORT",
        "UNSIGNED_SHORT_4_4_4_4",
        "UNSIGNED_SHORT_5_5_5_1",
        "UNSIGNED_SHORT_5_6_5",
        "VALIDATE_STATUS",
        "VENDOR",
        "VERSION",
        "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
        "VERTEX_ATTRIB_ARRAY_ENABLED",
        "VERTEX_ATTRIB_ARRAY_NORMALIZED",
        "VERTEX_ATTRIB_ARRAY_POINTER",
        "VERTEX_ATTRIB_ARRAY_SIZE",
        "VERTEX_ATTRIB_ARRAY_STRIDE",
        "VERTEX_ATTRIB_ARRAY_TYPE",
        "VERTEX_SHADER",
        "VIEWPORT",
        "ZERO",
    ]


    const webGlFp = () => {
        const wg2 = document.createElement("canvas").getContext("webgl2");

        {
            const c = document.createElement("canvas")
            const wg = c.getContext("webgl") || c.getContext("experimental-webgl");

            if(wg){
                HEAP.wgParams = Object.fromEntries(x.map((param) => [param,(wg[param] && wg.getParameter(wg[param])) || 0]))
                console.log(HEAP.wgParams)
            }
        }


        let result = wg2 ? undefined : "NA";

        HARDWARE.wg2 = {
            MAX_VIEWPORT_DIMS: result || Array.from(wg2.getParameter(wg2.MAX_VIEWPORT_DIMS)).slice(0, 2).join("|"),
            MAX_VERTEX_UNIFORM_COMPONENTS: result || wg2.getParameter(wg2.MAX_VERTEX_UNIFORM_COMPONENTS),
            MAX_VERTEX_UNIFORM_VECTORS: result || wg2.getParameter(wg2.MAX_VERTEX_UNIFORM_VECTORS),
        }

        HARDWARE_UNSTABLE.wg2 = {
            MAX_SAMPLES: result || wg2.getParameter(wg2.MAX_SAMPLES),
        }
    }

    const getVoicesHash = () => {
        const withResolve = () => {
            let resolve = null;
            const promise = new Promise((r) => {
                resolve = r;
            })

            return {
                promise,
                resolve,
            }
        }

        const isOsVoice = (() => {
            const browserVoices = ["google", "desktop"];
            return (voice) => {
                const normalized = voice.name.toLowerCase();

                return !browserVoices.some((browserVoice) => normalized.includes(browserVoice))
            }
        })()

        const normalizeVoiceName = (str) => str.replace(/\s+|\([^()]*\)/g, "").toLowerCase();

        const log = (v) => {
            console.log(v);

            return v
        }

        const shingles = (str, size = 3) => {
            const result = [];
            for (let i = 0; i <= str.length - size; i++) {
                result.push(str.slice(i, i + size));
            }
            return result;
        };

        function hash64(str) {
            let h = 0n;
            for (let i = 0; i < str.length; i++) {
                h = (h << 5n) - h + BigInt(str.charCodeAt(i));
                h &= (1n << 64n) - 1n;
            }
            return h;
        }

        function simHash64(features) {
            const bits = Array(64).fill(0);

            for (const f of features) {
                const h = hash64(f);
                for (let i = 0; i < 64; i++) {
                    bits[i] += (h >> BigInt(i)) & 1n ? 1 : -1;
                }
            }

            let result = 0n;
            for (let i = 0; i < 64; i++) {
                if (bits[i] > 0) {
                    result |= 1n << BigInt(i);
                }
            }

            return result.toString();
        }

        const mapToHashes = (mapWithFeatures) =>
            Object.fromEntries(Object.entries(mapWithFeatures).map(([lang, features]) =>  [lang, simHash64(features)]));

        const mapToFeatures = (map) =>
            Object.fromEntries(Object.entries(map).map(([lang, voices]) =>  [lang, voices.flatMap((voice) => shingles(voice))]));

        const mapToStr = (mapWithHash) => {
            const keys = Object.keys(mapWithHash).sort();
            return keys.map((key) => `${key}${mapWithHash[key]}`).join("")
        }

        const toSimHash = (str) => simHash64(shingles(str))

        const onVoiceChanged = withResolve();

        speechSynthesis.getVoices();
        speechSynthesis.addEventListener && speechSynthesis.addEventListener("voiceschanged", onVoiceChanged.resolve);
        setTimeout(onVoiceChanged.resolve, 200);

        return new Promise((resolve) => {
            onVoiceChanged.promise.then(() => {
                const base = speechSynthesis.getVoices()

                const voices = base
                    .filter(isOsVoice)
                    .reduce((acc, voice) => {
                        const key = voice.lang.split("-")[1];
                        acc[key] = acc[key] || [];
                        acc[key].push(normalizeVoiceName(voice.name));

                        return acc;
                    }, {})

                console.log(voices)

                const result = [mapToFeatures,log, mapToHashes, log, mapToStr, log,toSimHash, log].reduce((acc, fn) => fn(acc), voices)

                resolve(result);
            })
        })
    };

    getVoicesHash()

    const main = () => {
        const audioCtx = new window.AudioContext();
        HARDWARE.hardwareConcurrency = navigator.hardwareConcurrency;
        HARDWARE.sampleRate = audioCtx.sampleRate;
        HARDWARE.maxChannelCount = audioCtx.destination.maxChannelCount;
        HARDWARE_UNSTABLE.colorDepth = screen.colorDepth;

        const HEAP_FONTS = [
            "Segoe UI",
            "Calibri",
            "San Francisco",
            "Helvetica Neue",
            "Ubuntu",
            "Cantarell",
            "Yu Gothic",
            "Hiragino Sans",
            "PingFang SC",
            "Malgun Gothic",
            "Noto Sans CJK",
            "Cambria",
            "Consolas",
            "Myriad Pro",
            "Avenir",
            "JetBrains Mono",
            "Fira Code",
            "DejaVu Sans",
            "Liberation Serif",
            "Roboto",
            "Symbol",
            "Lora",
            "MingLiU_HKSCS-ExtB"
        ].map((font) => Number(hasFont(font))).join("")

        OS_PARTIALLY_STABLE.fonts = {
            microsoft: hasFont("Microsoft YaHei"),
            apple: hasFont("AppleGothic"),
            droid: hasFont("Droid Sans Mono"),
            heapFonts: `${Number.parseInt(HEAP_FONTS, 2)}|${HEAP_FONTS}`,
        };

        OS_RARELY_CHANGEABLE.language = navigator.language;
        OS_RARELY_CHANGEABLE.darkTheme = window.matchMedia("(prefers-color-scheme: dark)").matches;
        OS_RARELY_CHANGEABLE.timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;


        webGlFp()

        getVoicesHash().then((result) => {
            OS_PARTIALLY_STABLE.voice = result;

            const sum = "" +
                HARDWARE.hardwareConcurrency +
                HARDWARE.sampleRate +
                HARDWARE.maxChannelCount +
                HARDWARE.wg2.MAX_VIEWPORT_DIMS +
                HARDWARE.wg2.MAX_VERTEX_UNIFORM_COMPONENTS +
                HARDWARE.wg2.MAX_VERTEX_UNIFORM_VECTORS +
                Number(OS_PARTIALLY_STABLE.fonts.microsoft) +
                Number(OS_PARTIALLY_STABLE.fonts.apple) +
                Number(OS_PARTIALLY_STABLE.fonts.droid) +
                HEAP_FONTS +
                OS_RARELY_CHANGEABLE.language +
                OS_RARELY_CHANGEABLE.darkTheme +
                OS_RARELY_CHANGEABLE.timeZone;


            async function sha256(message) {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);

                const hashBuffer = await crypto.subtle.digest("SHA-256", data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));

                return hashArray
                    .map(b => b.toString(16).padStart(2, "0"))
                    .join("");
            }


            sha256(sum).then((result) => {
                fingerprint.innerText = result.slice(0, 4) + OS_PARTIALLY_STABLE.voice;
            })

            renderResult();
        });
    };

    main()


</script>
</html>
