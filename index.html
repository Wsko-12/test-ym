<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        if(false){
            (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
                m[i].l=1*new Date();
                for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
                k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
            (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

            ym(102462605, "init", {
                clickmap:true,
                trackLinks:true,
                accurateTrackBounce:true,
                webvisor:true
            });
        }
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/102462605" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->





    <script>
        if(false){
            const start = performance.now();
            // Initialize the agent on page load.
            const fpPromise = import('https://fpjscdn.net/v3/cheURAKfVuViSYMWYbi2')
                .then(FingerprintJS => FingerprintJS.load());

            // Pass your own data to get()
            fpPromise
                .then(fp => fp.get())
                .then(result => {
                    console.log(result);
                    console.log(performance.now() - start)
                });

        }


    </script>

    <!-- <script src="https://wsko-12.github.io/wwskgithubo.js"></script> -->
</head>
<body>
<h1 id="fingerprint"></h1>
</body>
<script>
    const p =           document.createElement("p")
    document.body.appendChild(p )

    navigator.storage.getDirectory().then(({kind}) => {
        p.innerText = kind
    }).catch((e) => {
        p.innerText = e.message
    })
</script>

<script type="module">
    const hasFont = (function () {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const testText = "mmmmmmmmmmlli";

        const baseFonts = ["monospace", "serif", "sans-serif"];

        const baseSizes = baseFonts.map(base => {
            ctx.font = `20px ${base}`;
            return ctx.measureText(testText).width;
        });

        return function (font) {
            return baseSizes.some((baseWidth, i) => {
                ctx.font = `20px "${font}", ${baseFonts[i]}`;
                const width = ctx.measureText(testText).width;
                return width !== baseWidth;
            });
        };
    })();

    const HARDWARE = {};
    const HARDWARE_UNSTABLE = {}
    const PERIPHERAL_HARDWARE = {};
    const OS_PARTIALLY_STABLE = {};
    const OS_RARELY_CHANGEABLE = {};
    const UNSTABLE = {};

    const renderResult = () => {
        const code = document.createElement("code");

        [
            ["HARDWARE", HARDWARE],
            ["HARDWARE_UNSTABLE", HARDWARE_UNSTABLE],
            ["OS_PARTIALLY_STABLE", OS_PARTIALLY_STABLE],
            ["OS_RARELY_CHANGEABLE", OS_RARELY_CHANGEABLE],
            ["UNSTABLE", UNSTABLE],
        ].forEach(([name, obj]) => {
            const pre = document.createElement("pre");
            code.appendChild(pre);
            pre.innerText += `${name}:\n ${JSON.stringify(obj, null, 2)} \n\n`;
        });

        document.body.appendChild(code);
    };


    const webGlFp = () => {
        const wg2 = document.createElement("canvas").getContext("webgl2");

        HARDWARE.wg2 = {
            MAX_VIEWPORT_DIMS: Array.from(wg2.getParameter(wg2.MAX_VIEWPORT_DIMS)).slice(0, 2).join("|"),
            MAX_VERTEX_UNIFORM_COMPONENTS: wg2.getParameter(wg2.MAX_VERTEX_UNIFORM_COMPONENTS),
            MAX_VERTEX_UNIFORM_VECTORS: wg2.getParameter(wg2.MAX_VERTEX_UNIFORM_VECTORS),
        }

        HARDWARE_UNSTABLE.wg2 = {
            MAX_SAMPLES: wg2.getParameter(wg2.MAX_SAMPLES),
        }
    }

    const getVoicesHash = () => {
        const withResolve = () => {
            let resolve = null;
            const promise = new Promise((r) => {
                resolve = r;
            })

            return {
                promise,
                resolve,
            }
        }

        const isOsVoice = (() => {
            const browserVoices = ["google", "desktop"];
            return (voice) => {
                const normalized = voice.name.toLowerCase();

                return !browserVoices.some((browserVoice) => normalized.includes(browserVoice))
            }
        })()

        const normalizeVoiceName = (str) => str.replace(/\s+|\([^()]*\)/g, "").toLowerCase();

        const log = (v) => {
            console.log(v);

            return v
        }

        const shingles = (str, size = 3) => {
            const result = [];
            for (let i = 0; i <= str.length - size; i++) {
                result.push(str.slice(i, i + size));
            }
            return result;
        };

        function hash64(str) {
            let h = 0n;
            for (let i = 0; i < str.length; i++) {
                h = (h << 5n) - h + BigInt(str.charCodeAt(i));
                h &= (1n << 64n) - 1n;
            }
            return h;
        }

        function simHash64(features) {
            const bits = Array(64).fill(0);

            for (const f of features) {
                const h = hash64(f);
                for (let i = 0; i < 64; i++) {
                    bits[i] += (h >> BigInt(i)) & 1n ? 1 : -1;
                }
            }

            let result = 0n;
            for (let i = 0; i < 64; i++) {
                if (bits[i] > 0) {
                    result |= 1n << BigInt(i);
                }
            }

            return result.toString();
        }

        const mapToHashes = (mapWithFeatures) =>
            Object.fromEntries(Object.entries(mapWithFeatures).map(([lang, features]) =>  [lang, simHash64(features)]));

        const mapToFeatures = (map) =>
            Object.fromEntries(Object.entries(map).map(([lang, voices]) =>  [lang, voices.flatMap((voice) => shingles(voice))]));

        const mapToStr = (mapWithHash) => {
            const keys = Object.keys(mapWithHash).sort();
            return keys.map((key) => `${key}${mapWithHash[key]}`).join("")
        }

        const toSimHash = (str) => simHash64(shingles(str))

        const onVoiceChanged = withResolve();

        speechSynthesis.getVoices();
        speechSynthesis.addEventListener("voiceschanged", onVoiceChanged.resolve);
        setTimeout(onVoiceChanged.resolve, 200);

        return new Promise((resolve) => {
            onVoiceChanged.promise.then(() => {
                const base = speechSynthesis.getVoices()

                const voices = base
                    .filter(isOsVoice)
                    .reduce((acc, voice) => {
                        const key = voice.lang.split("-")[1];
                        acc[key] = acc[key] || [];
                        acc[key].push(normalizeVoiceName(voice.name));

                        return acc;
                    }, {})

                console.log(voices)

                const result = [mapToFeatures,log, mapToHashes, log, mapToStr, log,toSimHash, log].reduce((acc, fn) => fn(acc), voices)

                resolve(result);
            })
        })
    };

    getVoicesHash()

    const main = () => {
        const audioCtx = new window.AudioContext();
        HARDWARE.hardwareConcurrency = navigator.hardwareConcurrency;
        HARDWARE.sampleRate = audioCtx.sampleRate;
        HARDWARE.maxChannelCount = audioCtx.destination.maxChannelCount;
        HARDWARE_UNSTABLE.colorDepth = screen.colorDepth;

        const HEAP_FONTS = [
            "Segoe UI",
            "Calibri",
            "San Francisco",
            "Helvetica Neue",
            "Ubuntu",
            "Cantarell",
            "Yu Gothic",
            "Hiragino Sans",
            "PingFang SC",
            "Malgun Gothic",
            "Noto Sans CJK",
            "Cambria",
            "Consolas",
            "Myriad Pro",
            "Avenir",
            "JetBrains Mono",
            "Fira Code",
            "DejaVu Sans",
            "Liberation Serif",
            "Roboto",
            "Symbol",
            "Lora",
            "MingLiU_HKSCS-ExtB"
        ].map((font) => Number(hasFont(font))).join("")

        OS_PARTIALLY_STABLE.fonts = {
            microsoft: hasFont("Microsoft YaHei"),
            apple: hasFont("AppleGothic"),
            droid: hasFont("Droid Sans Mono"),
            heapFonts: `${Number.parseInt(HEAP_FONTS, 2)}|${HEAP_FONTS}`,
        };

        OS_RARELY_CHANGEABLE.language = navigator.language;
        OS_RARELY_CHANGEABLE.darkTheme = window.matchMedia("(prefers-color-scheme: dark)").matches;
        OS_RARELY_CHANGEABLE.timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;


        webGlFp()

        getVoicesHash().then((result) => {
            OS_PARTIALLY_STABLE.voice = result;

            const sum = "" +
                HARDWARE.hardwareConcurrency +
                HARDWARE.sampleRate +
                HARDWARE.maxChannelCount +
                HARDWARE.wg2.MAX_VIEWPORT_DIMS +
                HARDWARE.wg2.MAX_VERTEX_UNIFORM_COMPONENTS +
                HARDWARE.wg2.MAX_VERTEX_UNIFORM_VECTORS +
                Number(OS_PARTIALLY_STABLE.fonts.microsoft) +
                Number(OS_PARTIALLY_STABLE.fonts.apple) +
                Number(OS_PARTIALLY_STABLE.fonts.droid) +
                HEAP_FONTS +
                OS_RARELY_CHANGEABLE.language +
                OS_RARELY_CHANGEABLE.darkTheme +
                OS_RARELY_CHANGEABLE.timeZone;


            async function digestMessage(message) {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                const hashBuffer = await window.crypto.subtle.digest("SHA-256", data);

                return  new Uint8Array(hashBuffer).toHex().slice(0, 8);
            }
            digestMessage(sum).then((result) => {
                fingerprint.innerText = result + OS_PARTIALLY_STABLE.voice;
            })

            renderResult();
        });
    };

    main()


</script>
</html>
